#include <algorithm>
#include <iostream>
#include <numeric>

#include "orq.h"

using namespace orq::debug;
using namespace orq::service;
using namespace COMPILED_MPC_PROTOCOL_NAMESPACE;

#define TEST_SIZE 1000

// **************************************** //
//            Test Bitonic Merge            //
// **************************************** //
template <typename T>
void test_bitonicMerge(int test_size) {
    test_size = 1 << (int)ceil(log2(test_size));

    const size_t half_size = test_size / 2;

    std::vector<T> v1(half_size), v2(half_size);
    for (int i = 0; i < half_size; i++) {
        v1[i] = rand();
        v2[i] = rand();
    }
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());

    std::vector<T> v3 = v1;
    v3.insert(v3.end(), v2.begin(), v2.end());

    orq::Vector<T> v(v3);

    BSharedVector<T> v_secret = secret_share_b(v, 0);
    orq::operators::bitonic_merge(v_secret);
    auto v_opened = v_secret.open();

    EncodedTable<T> table = secret_share<T>({v}, {"[V]"});
    table.sort({{"[V]", SortOrder::ASC}}, orq::SortingProtocol::BITONICMERGE);
    auto table_opened = table.open_with_schema();
    auto v_opened_table = table_opened.first[0];

    std::sort(v3.begin(), v3.end());
    if (orq::service::runTime->getPartyID() == 0) {
        assert(v_opened.same_as(v3));
        assert(v_opened.size() == test_size);
        assert(v_opened_table.same_as(v3));
        assert(v_opened_table.size() == test_size);
    }
}

// **************************************** //
//              Test Quicksort              //
// **************************************** //
template <typename T>
void test_quicksort(int test_size) {
    Vector<T> v(test_size);
    for (int i = 0; i < test_size; i++) {
        v[i] = i;
    }

    v[test_size / 2] = -1;

    BSharedVector<T> nums = secret_share_b(v, 0);
    nums.shuffle();
    Vector<T> shuffled = nums.open();

    BSharedVector<T> b1 = secret_share_b(shuffled, 0);
    BSharedVector<T> b2 = secret_share_b(shuffled, 0);
    BSharedVector<T> b1_reversed = secret_share_b(shuffled, 0);
    BSharedVector<T> b2_reversed = secret_share_b(shuffled, 0);

    // sort b1 and apply the sorting permutation to b2
    auto permutation = orq::operators::quicksort(b1);
    oblivious_apply_elementwise_perm(b2, permutation);

    // sort b1_reversed in reverse and apply the sorting permutation to b2_reversed
    auto reversed_permutation = orq::operators::quicksort(b1_reversed, SortOrder::DESC);
    oblivious_apply_elementwise_perm(b2_reversed, reversed_permutation);

    auto b1_opened = b1.open();
    auto b2_opened = b2.open();
    auto b1_reversed_opened = b1_reversed.open();
    auto b2_reversed_opened = b2_reversed.open();

    std::sort(v.begin(), v.end());

    assert(b1_opened.same_as(v));
    assert(b2_opened.same_as(v));

    for (int i = 0; i < test_size; i++) {
        assert(b1_reversed_opened[i] == v[test_size - i - 1]);
        assert(b2_reversed_opened[i] == v[test_size - i - 1]);
    }
}

// // **************************************** //
// //             Test GenBitPerm              //
// // **************************************** //
// void test_gen_bit_perm(int test_size) {
//     auto pID = runTime->getPartyID();

//     orq::Vector<int> v(test_size);
//     runTime->populateLocalRandom(v);

//     ASharedVector<int> s(2 * test_size);
//     using E = EVector<int>;

//     // test every bit
//     for (int bit = 0; bit < 32; bit++) {
//         // all parties will agree on the random vector generated by party 0
//         BSharedVector<int> b = secret_share_b(v, 0);

//         // generate the single bit permutation
//         auto permutation = gen_bit_perm<E>(*(b >> bit), s);

//         orq::operators::oblivious_apply_elementwise_perm(b, permutation);

//         // get the sorted bit (shift to avoid negatives in sign bit)
//         b.mask(1 << bit);
//         auto b_opened = b.open() >> bit;
//         b_opened.mask(1);

//         for (int i = 0; i < b_opened.size()-1; i++) {
//             assert(b_opened[i] <= b_opened[i+1]);
//         }
//     }
// }

// **************************************** //
//             Test Radix Sort              //
// **************************************** //
template <typename T>
void test_radix_sort(int test_size) {
    Vector<T> v(test_size);
    for (int i = 0; i < test_size; i++) {
        v[i] = i;
    }

    v[test_size / 2] = -1;

    BSharedVector<T> nums = secret_share_b(v, 0);
    nums.shuffle();
    Vector<T> shuffled = nums.open();

    BSharedVector<T> b1 = secret_share_b(shuffled, 0);
    BSharedVector<T> b2 = secret_share_b(shuffled, 0);
    BSharedVector<T> b1_reversed = secret_share_b(shuffled, 0);
    BSharedVector<T> b2_reversed = secret_share_b(shuffled, 0);

    // sort b1 and apply the sorting permutation to b2
    auto permutation = orq::operators::radix_sort(b1);
    orq::operators::oblivious_apply_elementwise_perm(b2, permutation);

    // sort b1_reversed in reverse and apply the sorting permutation to b2_reversed
    auto reversed_permutation = orq::operators::radix_sort(b1_reversed, SortOrder::DESC);
    oblivious_apply_elementwise_perm(b2_reversed, reversed_permutation);

    auto b1_opened = b1.open();
    auto b2_opened = b2.open();
    auto b1_reversed_opened = b1_reversed.open();
    auto b2_reversed_opened = b2_reversed.open();

    std::sort(v.begin(), v.end());

    assert(b1_opened.same_as(v));
    assert(b2_opened.same_as(v));

    for (int i = 0; i < test_size; i++) {
        assert(b1_reversed_opened[i] == v[test_size - i - 1]);
        assert(b2_reversed_opened[i] == v[test_size - i - 1]);
    }
}

// **************************************** //
//            Test Valid Bit Sort           //
// **************************************** //
void test_valid_bit_sorting(int test_size) {
    auto pID = runTime->getPartyID();

    orq::Vector<int> v(test_size);
    runTime->populateLocalRandom(v);

    v.mask(1);

    BSharedVector<int> b1 = secret_share_b(v, 0);
    BSharedVector<int> b1_non_sort = secret_share_b(v, 0);
    BSharedVector<int> b2 = secret_share_b(v, 0);
    BSharedVector<int> b2_non_sort = secret_share_b(v, 0);

    auto perm1 = orq::operators::radix_sort(b1, SortOrder::ASC, 1);
    auto perm2 = orq::operators::radix_sort(b2, SortOrder::DESC, 1);

    orq::operators::oblivious_apply_elementwise_perm(b1_non_sort, perm1);
    orq::operators::oblivious_apply_elementwise_perm(b2_non_sort, perm2);

    auto o1 = b1.open();
    auto o1_non_sort = b1_non_sort.open();
    auto o2 = b2.open();
    auto o2_non_sort = b2_non_sort.open();

    for (int i = 0; i < test_size - 1; i++) {
        assert(o1[i + 1] >= o1[i]);
        assert(o1[i] == o1_non_sort[i]);
        assert(o2[i + 1] <= o2[i]);
        assert(o2[i] == o2_non_sort[i]);
    }
}

// **************************************** //
//        Test Table Sort (One Column)      //
// **************************************** //
void test_table_sort_single(int num_rows, int num_columns, orq::SortingProtocol protocol) {
    // generate a table
    std::vector<orq::Vector<int>> table_data;
    std::vector<std::string> schema;
    for (int i = 0; i < num_columns; i++) {
        table_data.push_back(orq::Vector<int>(num_rows));
        // make even columns binary and odd columns arithmetic
        if (i % 2 == 0) {
            schema.push_back("[" + std::to_string(i) + "]");
        } else {
            schema.push_back(std::to_string(i));
        }
        for (int j = 0; j < num_rows; j++) {
            table_data[i][j] = j;
        }
    }
    EncodedTable<int> table1 = secret_share(table_data, schema);
    EncodedTable<int> table2 = secret_share(table_data, schema);

    table1.shuffle();
    table2.shuffle();

    table1.sort({"[0]"}, ASC, protocol);
    table2.sort({"[0]"}, DESC, protocol);

    // open
    std::vector<orq::Vector<int>> opened1 = table1.open();
    std::vector<orq::Vector<int>> opened2 = table2.open();
    // make sure all columns have the same value for each row
    for (int i = 0; i < num_rows; i++) {
        for (int j = 0; j < num_columns; j++) {
            assert(opened1[j][i] == i);
            assert(opened2[j][i] == num_rows - i - 1);
        }
    }

    // Make sure we used all of our perms
    assert(orq::random::PermutationManager::get()->size() == 0);
    assert(orq::random::PermutationManager::get()->size_pairs() == 0);
}

// **************************************** //
//      Test Table Sort (Multi Column)      //
// **************************************** //
void test_table_sort_multi(int num_rows, int num_columns, orq::SortingProtocol protocol,
                           bool test_tiebreak_explicit) {
    auto localPRG = runTime->rand0()->localPRG;

    single_cout("## Perms in Q: " << PermutationManager::get()->size());
    single_cout("## Pairs in Q: " << PermutationManager::get()->size_pairs());

    // generate a table
    std::vector<orq::Vector<int>> table_data;
    std::vector<std::string> schema;
    for (int i = 0; i < num_columns; i++) {
        table_data.push_back(orq::Vector<int>(num_rows));
        // make even columns binary and odd columns arithmetic
        if (i % 2 == 0) {
            schema.push_back("[" + std::to_string(i) + "]");
        } else {
            schema.push_back(std::to_string(i));
        }
        for (int j = 0; j < num_rows; j++) {
            localPRG->getNext(table_data[i][j]);
            if (table_data[i][j] < 0) {
                table_data[i][j] *= -1;
            }
            table_data[i][j] %= num_rows;
            if (test_tiebreak_explicit) {
                table_data[i][j] %= 2;
            }
        }
    }
    EncodedTable<int> table1 = secret_share(table_data, schema);
    EncodedTable<int> table2 = secret_share(table_data, schema);

    std::vector<std::pair<std::string, SortOrder>> spec;
    for (int i = 0; i < num_columns; i += 4) {
        spec.push_back(std::make_pair("[" + std::to_string(i) + "]", ASC));

        if (i + 2 < num_columns) {
            spec.push_back(std::make_pair("[" + std::to_string(i + 2) + "]", DESC));
        }
    }

    // get the actual sorting
    table1.sort(spec, protocol);

    // get the correct sorting
    for (int i = spec.size() - 1; i >= 0; i--) {
        std::vector<std::pair<std::string, SortOrder>> column_spec;
        column_spec.push_back(spec[i]);

        // sort the table on the single column
        table2.sort(column_spec, protocol);
    }

    auto t1_opened = table1.open();
    auto t2_opened = table2.open();
    for (int i = 0; i < num_columns; i++) {
        for (int j = 0; j < num_rows; j++) {
            assert(t1_opened[i][j] == t2_opened[i][j]);
        }
    }
}

// **************************************** //
//                Test Merge                //
// **************************************** //
void test_odd_even_merge(int test_size) {
    Vector<int> nums(test_size);
    for (int i = 0; i < test_size; i++) {
        nums[i] = i;
    }

    // secret share and shuffle the vector
    BSharedVector<int> v = secret_share_b(nums, 0);
    v.shuffle();

    // sort each half of the list
    orq::Vector<int> shuffled = v.open();
    std::vector<int> first_half(test_size / 2);
    std::vector<int> second_half(test_size / 2);
    for (int i = 0; i < test_size / 2; i++) {
        first_half[i] = shuffled[i];
        second_half[i] = shuffled[test_size / 2 + i];
    }
    std::sort(first_half.begin(), first_half.end());
    std::sort(second_half.begin(), second_half.end());
    // recombine and share
    orq::Vector<int> vec_to_merge(test_size);
    for (int i = 0; i < test_size / 2; i++) {
        vec_to_merge[i] = first_half[i];
        vec_to_merge[test_size / 2 + i] = second_half[i];
    }
    BSharedVector<int> v2 = secret_share_b(vec_to_merge, 0);

    orq::operators::odd_even_merge(v2);
    auto result = v2.open();
    for (int i = 0; i < test_size; i++) {
        assert(result[i] == i);
    }
}

int main(int argc, char** argv) {
    orq_init(argc, argv);

    test_bitonicMerge<int>(TEST_SIZE);
    single_cout("Bitonic Merge...OK");
    test_bitonicMerge<int64_t>(TEST_SIZE);
    single_cout("Bitonic Merge 64...OK");

    test_quicksort<int>(TEST_SIZE);
    single_cout("Quicksort...OK");
    test_quicksort<int64_t>(TEST_SIZE);
    single_cout("Quicksort 64...OK");

    // test_gen_bit_perm(10000);
    // single_cout("GenBitPerm...OK");

    test_radix_sort<int>(TEST_SIZE);
    single_cout("Radix Sort...OK");
    test_radix_sort<int64_t>(TEST_SIZE);
    single_cout("Radix Sort 64...OK");

    test_valid_bit_sorting(TEST_SIZE * 10);
    single_cout("Valid Bit Sort...OK");

    // test_table_sort_single(1024, 6, orq::SortingProtocol::BITONICSORT);
    // single_cout("Table Sort Bitonic...");
    single_cout("TS RS...");
    test_table_sort_single(1024, 6, orq::SortingProtocol::RADIXSORT);
    single_cout("TS QS...");
    test_table_sort_single(1024, 6, orq::SortingProtocol::QUICKSORT);
    single_cout("Table Sort (Single Sort Column)...OK");

    single_cout("TS Multi RS...");
    test_table_sort_multi(256, 8, orq::SortingProtocol::RADIXSORT, false);
    test_table_sort_multi(256, 8, orq::SortingProtocol::RADIXSORT, true);
    single_cout("TS Multi QS...");
    test_table_sort_multi(256, 8, orq::SortingProtocol::QUICKSORT, false);
    test_table_sort_multi(256, 8, orq::SortingProtocol::QUICKSORT, true);
    single_cout("Table Sort (Multiple Sort Columns)...OK");

    test_odd_even_merge(16384);
    single_cout("Odd-Even Merge...OK");

    // Tear down communication

    return 0;
}
