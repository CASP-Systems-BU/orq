#ifndef SECRECY_REPLICATED_3PC_H
#define SECRECY_REPLICATED_3PC_H

#include "../../debug/debug.h"
#include "protocol.h"
#include "protocol_factory.h"

using namespace secrecy::debug;

namespace secrecy {
// Assumes: ShareVector has type of pair of gavel::vector
// Communicator and random data generator still expects gavel::vector
/**
 * Implements the secure primitives for the 3-party semi-honest protocol
 * by Araki et al. that uses replicated secret sharing.
 * @tparam Data - Plaintext data type.
 * @tparam Share - Replicated share type.
 * @tparam Vector - Data container type.
 * @tparam EVector - Share container type.
 */
template <typename Data, typename Share, typename Vector, typename EVector>
class Replicated_3PC : public Protocol<Data, Share, Vector, EVector> {
   public:
    // Configuration Parameters
    static int parties_num;

    /**
     * Constructor for the semi-honest replicated 3-party protocol by Araki et al.
     * @param _partyID - The (globally) unique id of the party that calls this constructor.
     * @param _communicator - A pointer to the communicator.
     * @param _randomnessManager - A pointer to the randomness manager.
     */
    Replicated_3PC(PartyID _partyID, Communicator *_communicator,
                   random::RandomnessManager *_randomnessManager)
        : Protocol<Data, Share, Vector, EVector>(_communicator, _randomnessManager, _partyID, 3,
                                                 2) {}

    void multiply_a(const EVector &x, const EVector &y, EVector &z) {
        // Number of elements
        long long size = x.size();
        // Generate 'size' random shares of zero
        // TODO (john): Change this so that the generator only gives us the required random numbers
        Vector local(size);
        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(local);
        // Local computation

        // TODO: same as and, we need a way to figure out this size (or an upper bound)
        local += x(0) * y(0);
        local += x(0) * y(1);
        local += x(1) * y(0);

        // Communication round
        Vector remote(size);
        this->communicator->exchangeShares(local, remote, 2, 1, size);
        // Return output shared vector
        z(0) = local;
        z(1) = remote;
    }

    // Algrithm:
    //  1- We start input with 3 secret shares (x1, x2, x3).
    //      However, our division algorithm requires 2 secret shares.
    //  2- Given replication, we can merge the first 2 shares to get x1' = x1 + x2.
    //  3- We have shares (x1', x3) which we can use to do trivial division on secret shares.
    //  4- We end up with (x1/c, x3/c) which are only two shares. However, we need 3 shares.
    //  5- We redistribute the shares (y1, y2) to be (y1 - r, r, y2) where r is a random number.
    //      r can be retrieved using a common seed between the parties. [y1 = x1/c, y2 = x3/c].
    //  6- The logic for calculating result and error used for correction is identical to that of
    //  2pc. 7- Based on inputs (x1', x3), We adjust it using remainder so that it is always
    //  positive. 8- We then check if the positive remainder is greater than the divisor. If so, we
    //  adjust the result.

    // *Moreover, for shares redistribution:
    //  The idea is that after the trivial division, we have 2 secret shares instead of 3 secret
    //  shares. In order, to redistribute the 2 secret shares into 3:
    //      1- We let one party generate random shares using a common seed.
    //      2- The other party who knows the seed can generate the same numbers and subtract them
    //      from its share. 3- In summary, we start with (x1, 0, x2) -> to end with (x1 - r, r, x2).
    //      Both are equal to x1+x2.

    std::pair<EVector, EVector> div_const_a(const EVector &x, const Data &c) {
        auto size = x.size();
        EVector res(size), err(size);

        if (this->partyID == 0) {
            // For shares redistribution
            Vector r(size);
            this->randomnessManager->commonPRGManager->get(+1)->getNext(r);

            // Naive division on (x1 + x2)
            auto x_sum = x(0) + x(1);
            res(0) = (x_sum) / c - r;

#ifdef USE_DIVISION_CORRECTION
            auto x_sum_neg = x_sum < 0;
            res(0) -= x_sum_neg;

            this->randomnessManager->commonPRGManager->get(+1)->getNext(r);
            err(0) = (x_sum) % c + x_sum_neg * c - r;
#endif
        } else if (this->partyID == 2) {
            // Naive division on (x3)
            res(0) = x(0) / c;

#ifdef USE_DIVISION_CORRECTION
            auto x_sum_neg = x(0) < 0;
            res(0) -= x_sum_neg;
            err(0) = x(0) % c + x_sum_neg * c - c;
#endif
        } else {
            // These are the same random numbers generated by party 0
            this->randomnessManager->commonPRGManager->get(-1)->getNext(res(0));
#ifdef USE_DIVISION_CORRECTION
            this->randomnessManager->commonPRGManager->get(-1)->getNext(err(0));
#endif
        }

        this->communicator->exchangeShares(res(0), res(1), 2, 1, size);
#ifdef USE_DIVISION_CORRECTION
        this->communicator->exchangeShares(err(0), err(1), 2, 1, size);
#endif

        return {res, err};
    }

    EVector dot_product_a(const EVector &x, const EVector &y, const int &aggSize) {
        // Number of elements
        const size_t size = x.size();

        // Local computation and aggergation
        auto local = x(0).dot_product(y(0), aggSize) + x(0).dot_product(y(1), aggSize) +
                     x(1).dot_product(y(0), aggSize);
        const size_t newSize = local.size();

        // Generate 'size' random shares of zero
        Vector r(newSize);
        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(r);
        local += r;

        // Communication round
        Vector remote(newSize);
        this->communicator->exchangeShares(local, remote, 2, 1, newSize);

        // Return output shared vector
        return std::vector<Vector>({local, remote});
    }

    void and_b(const EVector &x, const EVector &y, EVector &z) {
        // Number of elements
        long long size = x.size();
        // Generate 'size' random shares of zero
        // TODO (john): Change this so that the generator only gives us the required random numbers
        // using each seed
        Vector local(size);
        this->randomnessManager->zeroSharingGenerator->getNextBinary(local);
        // Local computation

        // only access these once
        local ^= x(0) & y(0);
        local ^= x(0) & y(1);
        local ^= x(1) & y(0);

        // Communication round
        Vector remote(size);
        this->communicator->exchangeShares(local, remote, 2, 1, size);

        // Return output shared vector
        // These need to be copies, due to access patterns!
        z(0) = local;
        z(1) = remote;
    }

    void not_b(const EVector &x, EVector &y) { y = ~x; }

    void not_b_1(const EVector &x, EVector &y) { y = !(x & 1); }

    // this should not be final
    // probably extra communication
    // for now, this should only be used for the least significant bit
    void b2a_bit(const EVector &x, EVector &y) {
        // make secret sharings of s0 and s1
        // Reuse s0(1) to store the LSB-masked version of x
        EVector s0(x.size());
        EVector s1(x.size());

        s0 = x;
        s0.mask(1);

        // only P0 XORs its two shares. Store in s0(1)
        if (this->partyID == 0) {
            s0(1) ^= s0(0);
        }

        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(s0(0));
        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(s1(0));
        if (this->partyID == 0) {
            s0(0) += s0(1);
        } else if (this->partyID == 1) {
            // P1 only considers its second share
            s1(0) += s0(1);
        }

        this->communicator->exchangeShares(s0(0), s0(1), 2, 1, s0.size());
        this->communicator->exchangeShares(s1(0), s1(1), 2, 1, s1.size());

        // Re-using s0 and s1 to avoid extra vector allocations
        s0 -= s1;
        // y = s0^2
        multiply_a(s0, s0, y);
    }

    std::pair<EVector, EVector> redistribute_shares_b(const EVector &x) {
        Vector vec = x(0) + x(1);
        return {secret_share_b(vec, 0), secret_share_b(x(0), 2)};
    }

    Data reconstruct_from_a(const std::vector<Share> &shares) {
        return shares[0][0] + shares[1][0] + shares[2][0];
    }

    Vector reconstruct_from_a(const std::vector<EVector> &shares) {
        return shares[0](0) + shares[1](0) + shares[2](0);
    }

    Data reconstruct_from_b(const std::vector<Share> &shares) {
        return shares[0][0] ^ shares[1][0] ^ shares[2][0];
    }

    Vector reconstruct_from_b(const std::vector<EVector> &shares) {
        return shares[0](0) ^ shares[1](0) ^ shares[2](0);
    }

    Vector open_shares_a(const EVector &shares) {
        // Parties open their local shares to other parties
        size_t size = shares.size();
        Vector shares_3(size);
        this->communicator->exchangeShares(shares(1), shares_3, 2, 1, size);
        return shares(0) + shares(1) + shares_3;
    }

    Vector open_shares_b(const EVector &shares) {
        // Parties open their local shares to other parties
        size_t size = shares.size();
        Vector shares_3(size);
        this->communicator->exchangeShares(shares(1), shares_3, 2, 1, size);
        return shares(0) ^ shares(1) ^ shares_3;
    }

    std::vector<Share> get_share_a(const Data &data) {
        Data share_1, share_2;
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        Data share_3 = data - share_1 - share_2;
        // Return vector of replicated arithmetic shares
        return {{share_1, share_2}, {share_2, share_3}, {share_3, share_1}};
    }

    std::vector<EVector> get_shares_a(const Vector &data) {
        Vector share_1(data.size()), share_2(data.size());
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        auto share_3 = data - share_1 - share_2;
        // Return vector of replicated a-shared vectors
        return {std::vector<Vector>({share_1, share_2}), std::vector<Vector>({share_2, share_3}),
                std::vector<Vector>({share_3, share_1})};
    }

    std::vector<Share> get_share_b(const Data &data) {
        Data share_1, share_2;
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        Data share_3 = data ^ share_1 ^ share_2;
        // Return vector of replicated boolean shares
        return {{share_1, share_2}, {share_2, share_3}, {share_3, share_1}};
    }

    std::vector<EVector> get_shares_b(const Vector &data) {
        Vector share_1(data.size()), share_2(data.size());
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        auto share_3 = data ^ share_1 ^ share_2;
        // Return vector of replicated b-shared vectors
        return {std::vector<Vector>({share_1, share_2}), std::vector<Vector>({share_2, share_3}),
                std::vector<Vector>({share_3, share_1})};
    }

    void replicate_shares() {
        // TODO (john): implement this function
        std::cerr << "Method 'replicate_shares()' is not supported by Replicated_3PC." << std::endl;
        exit(-1);
    }

    EVector secret_share_b(const Vector &data, const PartyID &data_party = 0) {
        auto size = data.size();
        if (this->partyID == data_party) {
            // Generate shares
            auto boolean_shares = get_shares_b(data);
            // Send first shared vector to the successor
            this->communicator->sendShares(boolean_shares[1](0), 1, size);
            this->communicator->sendShares(boolean_shares[1](1), 1, size);
            // Send second shared vector to the predecessor
            this->communicator->sendShares(boolean_shares[2](0), 2, size);
            this->communicator->sendShares(boolean_shares[2](1), 2, size);
            return boolean_shares[0];
        } else {
            EVector s(size);
            // Receive shared vector from the predecessor
            this->communicator->receiveShares(s(0), data_party - this->partyID, size);
            this->communicator->receiveShares(s(1), data_party - this->partyID, size);
            return s;
        }
    }

    EVector secret_share_a(const Vector &data, const PartyID &data_party = 0) {
        auto size = data.size();
        if (this->partyID == data_party) {
            // Generate shares
            auto arithmetic_shares = get_shares_a(data);
            // Send first shared vector to the successor
            this->communicator->sendShares(arithmetic_shares[1](0), 1, size);
            this->communicator->sendShares(arithmetic_shares[1](1), 1, size);
            // Send second shared vector to the predecessor
            this->communicator->sendShares(arithmetic_shares[2](0), 2, size);
            this->communicator->sendShares(arithmetic_shares[2](1), 2, size);
            return arithmetic_shares[0];
        } else {
            EVector s(size);
            // Receive second shared vector from the predecessor
            this->communicator->receiveShares(s(0), data_party - this->partyID, size);
            this->communicator->receiveShares(s(1), data_party - this->partyID, size);
            return s;
        }
    }

    EVector public_share(const Vector &x) {
        auto size = x.size();
        auto zero1 = Vector(size);
        auto zero2 = Vector(size);
        switch (this->partyID) {
            case 0:
                return std::vector<Vector>({x, zero1});
            case 1:
                return std::vector<Vector>({zero1, zero2});
            case 2:
                return std::vector<Vector>({zero1, x});
            default:
                throw std::runtime_error("Invalid party ID");
        }
    }
};
// TODO (john): Why not initializing parties_num as static const int?
template <typename Data, typename Share, typename Vector, typename EVector>
int Replicated_3PC<Data, Share, Vector, EVector>::parties_num = 3;

template <template <typename> class Share, template <typename> class Vector,
          template <typename> class EVector>
using Replicated_3PC_Factory = DefaultProtocolFactory<Replicated_3PC, Share, Vector, EVector>;

}  // namespace secrecy

#endif  // SECRECY_REPLICATED_3PC_H
