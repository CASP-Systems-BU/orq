#pragma once

#include "debug/orq_debug.h"
#include "protocol.h"
#include "protocol_factory.h"

using namespace orq::debug;

namespace orq {
/**
 * @brief Implements the secure primitives for the 3-party semi-honest protocol by Araki et al.
 * that uses replicated secret sharing.
 *
 * @tparam Data Plaintext data type.
 * @tparam Share Replicated share type.
 * @tparam Vector Data container type.
 * @tparam EVector Share container type.
 */
template <typename Data, typename Share, typename Vector, typename EVector>
class Replicated_3PC : public Protocol<Data, Share, Vector, EVector> {
   public:
    // Configuration Parameters
    static int parties_num;

    /**
     * @brief Constructor for the semi-honest replicated 3-party protocol by Araki et al.
     *
     * @param _partyID The (globally) unique id of the party that calls this constructor.
     * @param _communicator A pointer to the communicator.
     * @param _randomnessManager A pointer to the randomness manager.
     */
    Replicated_3PC(PartyID _partyID, Communicator *_communicator,
                   random::RandomnessManager *_randomnessManager)
        : Protocol<Data, Share, Vector, EVector>(_communicator, _randomnessManager, _partyID, 3,
                                                 2) {}

    /**
     * @brief Secure arithmetic multiplication using replicated secret sharing.
     *
     * @param x First input vector.
     * @param y Second input vector.
     * @param z Output vector.
     */
    void multiply_a(const EVector &x, const EVector &y, EVector &z) {
        // Number of elements
        long long size = x.size();
        // Generate 'size' random shares of zero
        // TODO (john): Change this so that the generator only gives us the required random numbers
        Vector local(size);
        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(local);
        // Local computation

        // TODO: same as and, we need a way to figure out this size (or an upper bound)
        local += x(0) * y(0);
        local += x(0) * y(1);
        local += x(1) * y(0);

        // Communication round
        Vector remote(size);
        this->communicator->exchangeShares(local, remote, 2, 1, size);
        // Return output shared vector
        z(0) = local;
        z(1) = remote;

        this->handle_precision(x, y, z);
        this->truncate(z);
    }

    /**
     * @brief Division by constant with share redistribution.
     *
     * Algorithm:
     * 1. Start with 3 secret shares (x1, x2, x3), but division requires 2 shares.
     * 2. Merge first 2 shares to get x1' = x1 + x2.
     * 3. Use shares (x1', x3) for division on secret shares.
     * 4. End up with (x1/c, x3/c) which are only two shares, but we need 3 shares.
     * 5. Redistribute shares (y1, y2) to be (y1 - r, r, y2) where r is random.
     * 6. Logic for calculating result and error is identical to 2PC.
     *
     * @param x Input vector.
     * @param c Constant divisor.
     * @return Pair of vectors (quotient and error correction).
     */
    std::pair<EVector, EVector> div_const_a(const EVector &x, const Data &c) {
        auto size = x.size();
        EVector res(size), err(size);

        if (this->partyID == 0) {
            // For shares redistribution
            Vector r(size);
            this->randomnessManager->commonPRGManager->get(+1)->getNext(r);

            // Naive division on (x1 + x2)
            auto x_sum = x(0) + x(1);
            res(0) = (x_sum) / c - r;

#ifdef USE_DIVISION_CORRECTION
            auto x_sum_neg = x_sum < 0;
            res(0) -= x_sum_neg;

            this->randomnessManager->commonPRGManager->get(+1)->getNext(r);
            err(0) = (x_sum) % c + x_sum_neg * c - r;
#endif
        } else if (this->partyID == 2) {
            // Naive division on (x3)
            res(0) = x(0) / c;

#ifdef USE_DIVISION_CORRECTION
            auto x_sum_neg = x(0) < 0;
            res(0) -= x_sum_neg;
            err(0) = x(0) % c + x_sum_neg * c - c;
#endif
        } else {
            // These are the same random numbers generated by party 0
            this->randomnessManager->commonPRGManager->get(-1)->getNext(res(0));
#ifdef USE_DIVISION_CORRECTION
            this->randomnessManager->commonPRGManager->get(-1)->getNext(err(0));
#endif
        }

        this->communicator->exchangeShares(res(0), res(1), 2, 1, size);
#ifdef USE_DIVISION_CORRECTION
        this->communicator->exchangeShares(err(0), err(1), 2, 1, size);
#endif

        return {res, err};
    }

    /**
     * @brief Secure dot product using replicated secret sharing.
     *
     * @param x First input vector.
     * @param y Second input vector.
     * @param aggSize Aggregation size.
     * @return Output vector containing dot products.
     */
    EVector dot_product_a(const EVector &x, const EVector &y, const int &aggSize) {
        // Number of elements
        const size_t size = x.size();

        // Local computation and aggergation
        auto local = x(0).dot_product(y(0), aggSize) + x(0).dot_product(y(1), aggSize) +
                     x(1).dot_product(y(0), aggSize);
        const size_t newSize = local.size();

        // Generate 'size' random shares of zero
        Vector r(newSize);
        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(r);
        local += r;

        // Communication round
        Vector remote(newSize);
        this->communicator->exchangeShares(local, remote, 2, 1, newSize);

        // Return output shared vector
        return std::vector<Vector>({local, remote});
    }

    /**
     * @brief Secure bitwise AND using replicated secret sharing.
     *
     * @param x First input vector.
     * @param y Second input vector.
     * @param z Output vector.
     */
    void and_b(const EVector &x, const EVector &y, EVector &z) {
        // Number of elements
        long long size = x.size();
        // Generate 'size' random shares of zero
        // TODO (john): Change this so that the generator only gives us the required random numbers
        // using each seed
        Vector local(size);
        this->randomnessManager->zeroSharingGenerator->getNextBinary(local);
        // Local computation

        // only access these once
        local ^= x(0) & y(0);
        local ^= x(0) & y(1);
        local ^= x(1) & y(0);

        // Communication round
        Vector remote(size);
        this->communicator->exchangeShares(local, remote, 2, 1, size);

        // Return output shared vector
        // These need to be copies, due to access patterns!
        z(0) = local;
        z(1) = remote;

        this->handle_precision(x, y, z);
    }

    /**
     * @brief Boolean complement operation.
     *
     * @param x Input vector.
     * @param y Output vector.
     */
    void not_b(const EVector &x, EVector &y) { y = ~x; }

    /**
     * @brief Boolean NOT operation (LSB only).
     *
     * @param x Input vector.
     * @param y Output vector.
     */
    void not_b_1(const EVector &x, EVector &y) { y = !(x & 1); }

    /**
     * @brief Convert boolean-shared bit to arithmetic sharing.
     *
     * Converts a boolean-shared bit (LSB only) to arithmetic sharing using
     * replicated secret sharing protocol.
     *
     * Should only be used for the least significant bit.
     *
     * @param x Input boolean shared vector.
     * @param y Output arithmetic shared vector.
     */
    void b2a_bit(const EVector &x, EVector &y) {
        // make secret sharings of s0 and s1
        // Reuse s0(1) to store the LSB-masked version of x
        EVector s0(x.size());
        EVector s1(x.size());

        s0 = x;
        s0.setPrecision(0);
        s0.mask(1);

        // only P0 XORs its two shares. Store in s0(1)
        if (this->partyID == 0) {
            s0(1) ^= s0(0);
        }

        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(s0(0));
        this->randomnessManager->zeroSharingGenerator->getNextArithmetic(s1(0));
        if (this->partyID == 0) {
            s0(0) += s0(1);
        } else if (this->partyID == 1) {
            // P1 only considers its second share
            s1(0) += s0(1);
        }

        this->communicator->exchangeShares(s0(0), s0(1), 2, 1, s0.size());
        this->communicator->exchangeShares(s1(0), s1(1), 2, 1, s1.size());

        // Re-using s0 and s1 to avoid extra vector allocations
        s0 -= s1;
        // y = s0^2
        multiply_a(s0, s0, y);
    }

    /**
     * @brief Redistribute boolean shares.
     *
     * @param x Input vector.
     * @return Pair of redistributed shared vectors.
     */
    std::pair<EVector, EVector> redistribute_shares_b(const EVector &x) {
        Vector vec = x(0) + x(1);
        return {secret_share_b(vec, 0), secret_share_b(x(0), 2)};
    }

    /**
     * @brief Reconstruct plaintext from arithmetic shares.
     *
     * @param shares Input shares from all three parties.
     * @return Reconstructed plaintext value.
     */
    Data reconstruct_from_a(const std::vector<Share> &shares) {
        return shares[0][0] + shares[1][0] + shares[2][0];
    }

    /**
     * @brief Reconstruct plaintext vector from arithmetic shares.
     *
     * @param shares Input shared vectors from all three parties.
     * @return Reconstructed plaintext vector.
     */
    Vector reconstruct_from_a(const std::vector<EVector> &shares) {
        return shares[0](0) + shares[1](0) + shares[2](0);
    }

    /**
     * @brief Reconstruct plaintext from boolean shares.
     *
     * @param shares Input shares from all three parties.
     * @return Reconstructed plaintext value.
     */
    Data reconstruct_from_b(const std::vector<Share> &shares) {
        return shares[0][0] ^ shares[1][0] ^ shares[2][0];
    }

    /**
     * @brief Reconstruct plaintext vector from boolean shares.
     *
     * @param shares Input shared vectors from all three parties.
     * @return Reconstructed plaintext vector.
     */
    Vector reconstruct_from_b(const std::vector<EVector> &shares) {
        return shares[0](0) ^ shares[1](0) ^ shares[2](0);
    }

    /**
     * @brief Open arithmetic shares to reveal plaintext.
     *
     * @param shares Input shared vector.
     * @return Opened plaintext vector.
     */
    Vector open_shares_a(const EVector &shares) {
        // Parties open their local shares to other parties
        size_t size = shares.size();
        Vector shares_3(size);
        this->communicator->exchangeShares(shares(1), shares_3, 2, 1, size);
        return shares(0) + shares(1) + shares_3;
    }

    /**
     * @brief Open boolean shares to reveal plaintext.
     *
     * @param shares Input shared vector.
     * @return Opened plaintext vector.
     */
    Vector open_shares_b(const EVector &shares) {
        // Parties open their local shares to other parties
        size_t size = shares.size();
        Vector shares_3(size);
        this->communicator->exchangeShares(shares(1), shares_3, 2, 1, size);
        return shares(0) ^ shares(1) ^ shares_3;
    }

    /**
     * @brief Generate replicated arithmetic shares for a single value.
     *
     * @param data Input plaintext value.
     * @return Vector of replicated arithmetic shares for all parties.
     */
    std::vector<Share> get_share_a(const Data &data) {
        Data share_1, share_2;
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        Data share_3 = data - share_1 - share_2;
        // Return vector of replicated arithmetic shares
        return {{share_1, share_2}, {share_2, share_3}, {share_3, share_1}};
    }

    /**
     * @brief Generate replicated arithmetic shares for a vector.
     *
     * @param data Input plaintext vector.
     * @return Vector of replicated arithmetic shared vectors for all parties.
     */
    std::vector<EVector> get_shares_a(const Vector &data) {
        Vector share_1(data.size()), share_2(data.size());
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        auto share_3 = data - share_1 - share_2;
        // Return vector of replicated a-shared vectors
        return {std::vector<Vector>({share_1, share_2}), std::vector<Vector>({share_2, share_3}),
                std::vector<Vector>({share_3, share_1})};
    }

    /**
     * @brief Generate replicated boolean shares for a single value.
     *
     * @param data Input plaintext value.
     * @return Vector of replicated boolean shares for all parties.
     */
    std::vector<Share> get_share_b(const Data &data) {
        Data share_1, share_2;
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        Data share_3 = data ^ share_1 ^ share_2;
        // Return vector of replicated boolean shares
        return {{share_1, share_2}, {share_2, share_3}, {share_3, share_1}};
    }

    /**
     * @brief Generate replicated boolean shares for a vector.
     *
     * @param data Input plaintext vector.
     * @return Vector of replicated boolean shared vectors for all parties.
     */
    std::vector<EVector> get_shares_b(const Vector &data) {
        Vector share_1(data.size()), share_2(data.size());
        this->randomnessManager->localPRG->getNext(share_1);
        this->randomnessManager->localPRG->getNext(share_2);
        auto share_3 = data ^ share_1 ^ share_2;
        // Return vector of replicated b-shared vectors
        return {std::vector<Vector>({share_1, share_2}), std::vector<Vector>({share_2, share_3}),
                std::vector<Vector>({share_3, share_1})};
    }

    /**
     * @brief Secret share a boolean vector using replicated sharing.
     *
     * @param data Input plaintext vector.
     * @param data_party Party that owns the data.
     * @return This party's replicated boolean shared vector.
     */
    EVector secret_share_b(const Vector &data, const PartyID &data_party = 0) {
        auto size = data.size();
        if (this->partyID == data_party) {
            // Generate shares
            auto boolean_shares = get_shares_b(data);
            // Send first shared vector to the successor
            this->communicator->sendShares(boolean_shares[1](0), 1, size);
            this->communicator->sendShares(boolean_shares[1](1), 1, size);
            // Send second shared vector to the predecessor
            this->communicator->sendShares(boolean_shares[2](0), 2, size);
            this->communicator->sendShares(boolean_shares[2](1), 2, size);
            return boolean_shares[0];
        } else {
            EVector s(size);
            // Receive shared vector from the predecessor
            this->communicator->receiveShares(s(0), data_party - this->partyID, size);
            this->communicator->receiveShares(s(1), data_party - this->partyID, size);
            return s;
        }
    }

    /**
     * @brief Secret share an arithmetic vector using replicated sharing.
     *
     * @param data Input plaintext vector.
     * @param data_party Party that owns the data.
     * @return This party's replicated arithmetic shared vector.
     */
    EVector secret_share_a(const Vector &data, const PartyID &data_party = 0) {
        auto size = data.size();
        if (this->partyID == data_party) {
            // Generate shares
            auto arithmetic_shares = get_shares_a(data);
            // Send first shared vector to the successor
            this->communicator->sendShares(arithmetic_shares[1](0), 1, size);
            this->communicator->sendShares(arithmetic_shares[1](1), 1, size);
            // Send second shared vector to the predecessor
            this->communicator->sendShares(arithmetic_shares[2](0), 2, size);
            this->communicator->sendShares(arithmetic_shares[2](1), 2, size);
            return arithmetic_shares[0];
        } else {
            EVector s(size);
            // Receive second shared vector from the predecessor
            this->communicator->receiveShares(s(0), data_party - this->partyID, size);
            this->communicator->receiveShares(s(1), data_party - this->partyID, size);
            return s;
        }
    }

    /**
     * @brief Create public shares from plaintext data using replicated sharing.
     *
     * @param x Input plaintext vector.
     * @return Public replicated shared vector.
     */
    EVector public_share(const Vector &x) {
        auto size = x.size();
        auto zero1 = Vector(size);
        auto zero2 = Vector(size);
        switch (this->partyID) {
            case 0:
                return std::vector<Vector>({x, zero1});
            case 1:
                return std::vector<Vector>({zero1, zero2});
            case 2:
                return std::vector<Vector>({zero1, x});
            default:
                throw std::runtime_error("Invalid party ID");
        }
    }
};

template <typename Data, typename Share, typename Vector, typename EVector>
int Replicated_3PC<Data, Share, Vector, EVector>::parties_num = 3;

/**
 * @brief Factory type alias for Replicated_3PC protocol.
 *
 * @tparam Share Share type template.
 * @tparam Vector Vector type template.
 * @tparam EVector Encoding vector type template.
 */
template <template <typename> class Share, template <typename> class Vector,
          template <typename> class EVector>
using Replicated_3PC_Factory = DefaultProtocolFactory<Replicated_3PC, Share, Vector, EVector>;

}  // namespace orq
