#include "../include/secrecy.h"

using namespace secrecy::debug;
using namespace secrecy::service;
using namespace COMPILED_MPC_PROTOCOL_NAMESPACE;

const int test_size = 1 << 16;
const int DIV_TEST_SIZE = 1 << 6;

template <typename T>
void test_b2a_bit(int test_size) {
    secrecy::Vector<T> v(test_size);
    runTime->populateLocalRandom(v);

    // all parties will agree on the random vector generated by party 0
    BSharedVector<T> b = secret_share_b(v, 0);
    b.mask(1);

    // perform the conversion
    ASharedVector<T> a = b.b2a_bit();

    // check that the binary and arithmetic openings are the same
    auto a_opened = a.open();
    auto b_opened = b.open();
    assert(a_opened.same_as(b_opened));
}

template <typename T>
void test_b2a(int test_size) {
    secrecy::Vector<T> v(test_size);
    runTime->populateLocalRandom(v);

    BSharedVector<T> b = secret_share_b(v, 0);
    ASharedVector<T> a = b.b2a();

    auto a_opened = a.open();
    auto b_opened = b.open();

    for (int i = 0; i < test_size; i++) {
        assert(a_opened[i] == b_opened[i]);
    }
}

// Define a test for secret-vs-plaintext binary operators
#define DEFINE_TEST_BINARY_OP(_op_, shareType, name)                   \
    template <typename T>                                              \
    void test_##name(int test_size) {                                  \
        auto L = std::numeric_limits<std::make_unsigned_t<T>>::digits; \
        single_cout_nonl(L << "-bit " #name "... ");                   \
        secrecy::Vector<T> x(test_size);                               \
        secrecy::Vector<T> y(test_size);                               \
                                                                       \
        if (runTime->getPartyID() == 0) {                              \
            runTime->populateLocalRandom(x);                           \
            runTime->populateLocalRandom(y);                           \
        }                                                              \
                                                                       \
        shareType<T> sx(test_size);                                    \
        shareType<T> sy(test_size);                                    \
        secret_share_vec(x, sx);                                       \
        secret_share_vec(y, sy);                                       \
                                                                       \
        auto sz = sx _op_ sy;                                          \
                                                                       \
        auto z1 = sz->open();                                          \
        auto z2 = x _op_ y;                                            \
                                                                       \
        if (runTime->getPartyID() == 0) {                              \
            assert(z1.same_as(z2));                                    \
            single_cout("OK");                                         \
        }                                                              \
    }

DEFINE_TEST_BINARY_OP(*, ASharedVector, multiplication);
DEFINE_TEST_BINARY_OP(+, BSharedVector, binary_add);
DEFINE_TEST_BINARY_OP(-, BSharedVector, binary_subtract);
DEFINE_TEST_BINARY_OP(&, BSharedVector, and);
DEFINE_TEST_BINARY_OP(^, BSharedVector, xor);
DEFINE_TEST_BINARY_OP(|, BSharedVector, or);
DEFINE_TEST_BINARY_OP(>, BSharedVector, greater_than);
DEFINE_TEST_BINARY_OP(<, BSharedVector, less_than);

template <typename T>
void test_private_division(int test_size) {
    using uT = std::make_unsigned_t<T>;
    auto L = std::numeric_limits<uT>::digits;
    single_cout_nonl("Boolean long division, " << L << "-bit... ");

    auto m = static_cast<double>(std::numeric_limits<T>::max());
    auto scale = static_cast<T>(sqrt(m));

    // Generate reasonable division test values
    Vector<uT> ub(test_size);
    runTime->populateLocalRandom(ub);
    ub = (ub % (scale - 1)) + 1;
    Vector<uT> q(test_size);
    runTime->populateLocalRandom(q);
    q = (q % (scale - 1)) + 1;

    Vector<T> b(test_size);
    b = ub;

    Vector<T> a(test_size);
    a = ub * q;

    auto truth = a / b;

    BSharedVector<T> a_ = secret_share_b(a, 0);
    BSharedVector<T> b_ = secret_share_b(b, 0);
    auto d = a_ / b_;
    auto opened = d->open();

    if (runTime->getPartyID() == 0) {
        assert(opened.same_as(truth));
    }

    single_cout("OK");
}

template <typename T>
void test_dot_product(int test_size, const int aggSize = 7) {
    auto L = std::numeric_limits<std::make_unsigned_t<T>>::digits;
    single_cout_nonl(L << "-bit dot product("<< aggSize << ")... ");

    if(test_size % aggSize != 0) {
        test_size*= aggSize;
    }

    secrecy::Vector<T> x(test_size), y(test_size);

    if (runTime->getPartyID() == 0) {
        runTime->populateLocalRandom(x);
        runTime->populateLocalRandom(y);
    }

    ASharedVector<T> sx = secret_share_a(x, 0);
    ASharedVector<T> sy = secret_share_a(y, 0);

    auto sz = sx.dot_product(sy, aggSize);
    auto z1 = sz->open();
    auto z2 = x.dot_product(y, aggSize);

    if (runTime->getPartyID() == 0) {
        assert(z1.same_as(z2));
        single_cout("OK");
    }
}

template <typename T>
void test_equals(int test_size) {
    auto L = std::numeric_limits<std::make_unsigned_t<T>>::digits;
    single_cout_nonl(L << "-bit equals...");
    secrecy::Vector<T> x(test_size), y(test_size);

    if (runTime->getPartyID() == 0) {
        runTime->populateLocalRandom(x);
        runTime->populateLocalRandom(y);
        y %= 3;
        y += x;
    }

    BSharedVector<T> sx = secret_share_b(x, 0);
    BSharedVector<T> sy = secret_share_b(y, 0);

    auto sz = sx == sy;
    auto z1 = sz->open();
    auto z2 = x == y;
    if (runTime->getPartyID() == 0) {
        assert(z1.same_as(z2));
        single_cout("OK");
    }
}

int main(int argc, char** argv) {
    // Initialize Secrecy runtime
    secrecy_init(argc, argv);

    // The party's unique id
    auto pID = runTime->getPartyID();

    // Input plaintext data for testing secure comparisons
    secrecy::Vector<int> data_a = {111, -4, -17, 2345, 999, 0, -28922, 1231241, 0, -23437};
    secrecy::Vector<int> data_b = {0, -4, -5, -123556, 999, 70, -243242, INT_MAX, 0, 78};

    assert(data_a.size() == data_b.size());

    // **************************************** //
    //           Basic Secret Sharing           //
    // **************************************** //

    {
        ASharedVector<int> a_v1 = secret_share_a(data_a, 0);
        BSharedVector<int> b_v1 = secret_share_b(data_a, 0);

        assert(a_v1.open().same_as(data_a));
        assert(b_v1.open().same_as(data_a));

        single_cout("Secret sharing... OK");
    }

    // **************************************** //
    //           Arithmetic primitives          //
    // **************************************** //
    ASharedVector<int> a_v1 = secret_share_a(data_a, 0);
    ASharedVector<int> a_v2 = secret_share_a(data_b, 0);

    // Apply elementwise secure addition
    ASharedVector<int> c_add = a_v1 + a_v2;
    // Open added numbers
    auto c_add_open = c_add.open();
    // Get ground truth
    secrecy::Vector<int> sum = (data_a + data_b);
    // Compare sums with ground truth
    assert(c_add_open.same_as(sum));

    if (pID == 0) std::cout << "Addition...OK" << std::endl;

    {
        ASharedVector<int> a_s = secret_share_a(data_a, 0);
        ASharedVector<int> b_s = secret_share_a(data_b, 0);

        a_s += b_s;

        assert(a_s.open().same_as(data_a + data_b));
        single_cout("Increment += OK");
    }

    // Apply elementwise secure addition
    ASharedVector<int> c_sub = a_v1 - a_v2;
    // Open added numbers
    auto c_sub_open = c_sub.open();
    // Get ground truth
    secrecy::Vector<int> sub = (data_a - data_b);
    // Compare diffs with ground truth
    assert(c_sub_open.same_as(sub));

    if (pID == 0) std::cout << "Subtraction...OK" << std::endl;

    {
        ASharedVector<int> a_s = secret_share_a(data_a, 0);
        ASharedVector<int> b_s = secret_share_a(data_b, 0);

        a_s -= b_s;

        assert(a_s.open().same_as(data_a - data_b));
        single_cout("Decrement -= OK");
    }

    test_multiplication<int8_t>(test_size);
    test_multiplication<int32_t>(test_size);
    test_multiplication<int64_t>(test_size);
    test_multiplication<__int128_t>(test_size);

    runTime->malicious_check();

    {
        ASharedVector<int> a_s = secret_share_a(data_a, 0);
        ASharedVector<int> b_s = secret_share_a(data_b, 0);

        a_s *= b_s;

        assert(a_s.open().same_as(data_a * data_b));
        single_cout("Multiply Assignment *= OK");
    }

    // TODO: check overflowing when dividing INT_MAX in fantastic four
    // secrecy::Vector<int> div_data = {111, 1231241, 999, 109, 0, -4, -17, 2345,   -28922, -23437};
    // secrecy::Vector<int> div_data = {0, -4, -5, -123556, 999, 70, -243242, INT_MAX, 0, 78};
    secrecy::Vector<int64_t> div_data = {0,      4,           5,       123556, 999, 70,
                                         243242, INT_MAX - 1, INT_MAX, 0,      78};
    ASharedVector<int64_t> shared_div_data = secret_share_a(div_data, 0);

    {
        // Apply elementwise secure public constant division
        ASharedVector<int64_t> c_div = shared_div_data / 8;

#ifdef MPC_PROTOCOL_REPLICATED_THREE
        // check for large truncation error
        int count_truncation_errors = 0;
        if (pID == 0) {
            // get the other share from party 2
            secrecy::Vector<int64_t> my_share = c_div.asEVector()(0);
            secrecy::Vector<int64_t> other_share(div_data.size());
            runTime->comm0()->receiveShares(other_share, +2, div_data.size());
            for (int i = 0; i < div_data.size(); i++) {
                int sign_x = (div_data[i] >= 0);
                int sign_x1 = (my_share[i] >= 0);
                int sign_x2 = (other_share[i] >= 0);
                if ((sign_x1 == sign_x2) && (sign_x1 != sign_x)) {
                    count_truncation_errors++;
                }
            }
            // send number of truncation errors
            runTime->comm0()->sendShare(count_truncation_errors, +1);
            runTime->comm0()->sendShare(count_truncation_errors, +2);
        } else if (pID == 2) {
            // send first share to party 0
            runTime->comm0()->sendShares(c_div.asEVector()(0), +1, div_data.size());
            // receive number of truncation errors
            runTime->comm0()->receiveShare(count_truncation_errors, +1);
        } else if (pID == 1) {
            // receive number of truncation errors
            runTime->comm0()->receiveShare(count_truncation_errors, +2);
        }

        // Open divided numbers
        auto c_div_open = c_div.open();
        // Get ground truth
        secrecy::Vector<int64_t> div = div_data / 8;
        // Compare division results with ground truth
        if (count_truncation_errors > 0) {
            if (pID == 0)
                std::cout << "WARNING: large truncation error occurred, skipping correctness check"
                          << std::endl;
        } else {
            assert(c_div_open.same_as(div));
        }
#else  // Other protocols: no truncation check
       // Open divided numbers
        auto c_div_open = c_div.open();
        // Get ground truth
        secrecy::Vector<int64_t> div = div_data / 8;
        // Compare division results with ground truth

        assert(c_div_open.same_as(div));
#endif
        if (pID == 0) std::cout << "Public Constant Division...OK" << std::endl;
    }

    // Apply elementwise secure arithmetic negation
    ASharedVector<int> c_a_neg = -a_v1;
    // Open added numbers
    auto c_a_neg_open = c_a_neg.open();
    // Get ground truth
    secrecy::Vector<int> a_neg = -data_a;
    // Compare negated elements with ground truth
    assert(c_a_neg_open.same_as(a_neg));

    if (pID == 0) std::cout << "Arithmetic negation...OK" << std::endl;

    // Test dot product
    test_dot_product<int8_t>(test_size, 7);
    test_dot_product<int8_t>(test_size, test_size);
    test_dot_product<int16_t>(test_size, 7);
    test_dot_product<int16_t>(test_size, test_size);
    test_dot_product<int32_t>(test_size, 7);
    test_dot_product<int32_t>(test_size, test_size);
    test_dot_product<int64_t>(test_size, 7);
    test_dot_product<int64_t>(test_size, test_size);
    test_dot_product<__int128_t>(test_size, 7);
    test_dot_product<__int128_t>(test_size, test_size);

    // **************************************** //
    //             Boolean primitives           //
    // **************************************** //

    // Secret-share original vectors using boolean sharing
    BSharedVector<int> b_v1 = secret_share_b(data_a, 0);
    BSharedVector<int> b_v2 = secret_share_b(data_b, 0);

    test_and<int8_t>(test_size);
    test_and<int32_t>(test_size);
    test_and<int64_t>(test_size);
    test_and<__int128_t>(test_size);

    {
        BSharedVector<int> a_s = secret_share_b(data_a, 0);
        BSharedVector<int> b_s = secret_share_b(data_b, 0);

        a_s &= b_s;

        assert(a_s.open().same_as(data_a & data_b));
        single_cout("Bitwise &= OK");
    }

    {
        BSharedVector<int> a_s = secret_share_b(data_a, 0);
        BSharedVector<int> b_s = secret_share_b(data_b, 0);

        a_s |= b_s;

        assert(a_s.open().same_as(data_a | data_b));
        single_cout("Bitwise |= OK");
    }

    {
        BSharedVector<int> a_s = secret_share_b(data_a, 0);
        BSharedVector<int> b_s = secret_share_b(data_b, 0);

        a_s ^= b_s;

        assert(a_s.open().same_as(data_a ^ data_b));
        single_cout("Bitwise ^= OK");
    }

    test_xor<int8_t>(test_size);
    test_xor<int32_t>(test_size);
    test_xor<int64_t>(test_size);
    test_xor<__int128_t>(test_size);

    test_or<int8_t>(test_size);
    test_or<int32_t>(test_size);
    test_or<int64_t>(test_size);
    test_or<__int128_t>(test_size);

    test_equals<int8_t>(test_size);
    test_equals<int32_t>(test_size);
    test_equals<int64_t>(test_size);
    test_equals<__int128_t>(test_size);

    test_greater_than<int8_t>(test_size);
    test_greater_than<int32_t>(test_size);
    test_greater_than<int64_t>(test_size);
    test_greater_than<__int128_t>(test_size);

    test_less_than<int8_t>(test_size);
    test_less_than<int32_t>(test_size);
    test_less_than<int64_t>(test_size);
    test_less_than<__int128_t>(test_size);

    // Apply elementwise secure boolean negation
    BSharedVector<int> c_b_neg = !(b_v1 == b_v2);
    // Open NOT results
    auto c_b_neg_open = c_b_neg.open();
    // Get ground truth
    secrecy::Vector<int> a_b_neg = !(data_a == data_b);

    // Compare NOT results with ground truth
    assert(c_b_neg_open.same_as(a_b_neg));

    if (pID == 0) std::cout << "Boolean NOT...OK" << std::endl;

    // Apply elementwise secure boolean negation
    BSharedVector<int> c_b_comp = ~b_v1;
    // Open NOT results
    auto c_b_comp_open = c_b_comp.open();
    // Get ground truth
    secrecy::Vector<int> a_b_comp = ~data_a;

    // Compare NOT results with ground truth
    assert(c_b_comp_open.same_as(a_b_comp));

    if (pID == 0) std::cout << "Boolean complement...OK" << std::endl;

    // Apply elementwise secure boolean addition with PPA
    BSharedVector<int> c_b_add_ppa = parallel_prefix_adder(b_v1, b_v2);
    // Open addition results
    auto c_b_add_ppa_open = c_b_add_ppa.open();
    // Get ground truth
    secrecy::Vector<int> a_b_add = data_a + data_b;

    // Compare addition results with ground truth
    assert(c_b_add_ppa_open.same_as(a_b_add));
    if (pID == 0) std::cout << "Parallel prefix adder...OK" << std::endl;

    test_binary_add<int8_t>(test_size);
    test_binary_add<int32_t>(test_size);
    test_binary_add<int64_t>(test_size);
    test_binary_add<__int128_t>(test_size);

    test_binary_subtract<int8_t>(test_size);
    test_binary_subtract<int32_t>(test_size);
    test_binary_subtract<int64_t>(test_size);
    test_binary_subtract<__int128_t>(test_size);

    // ...with carry in
    auto c_b_add_rca = ripple_carry_adder(b_v1, b_v2, true);
    auto c_b_add_rca_open = c_b_add_rca->open();
    assert(c_b_add_rca_open.same_as(a_b_add + 1));
    if (pID == 0) std::cout << "RCA carry in...OK" << std::endl;

    // ...subtraction
    auto c_b_sub_rca = b_v1 - b_v2;
    auto c_b_sub_rca_open = c_b_sub_rca->open();
    assert(c_b_sub_rca_open.same_as(data_a - data_b));
    if (pID == 0) std::cout << "RCA subtraction...OK" << std::endl;

    // ...compare
    {
        auto rca_cmp = rca_compare(b_v1, b_v2);
        auto opened = rca_cmp->open();
        assert(opened.same_as(data_a < data_b));
        single_cout("RCA cmp... OK");
    }

    // Private Division
    test_private_division<int8_t>(DIV_TEST_SIZE);
    test_private_division<int32_t>(DIV_TEST_SIZE);
    test_private_division<int64_t>(DIV_TEST_SIZE);

    // **************************************** //
    //             Other primitives             //
    // **************************************** //

    // TODO (john): Add tests for mask() and set_bit();

    BSharedVector<int> a2b1 = a_v1.a2b();
    BSharedVector<int> a2b2 = a_v2.a2b();

    auto a2b1_open = a2b1.open();
    auto a2b2_open = a2b2.open();

    assert(a2b1_open.same_as(data_a));
    assert(a2b2_open.same_as(data_b));

    if (pID == 0) std::cout << "Arithmetic to boolean conversion...OK" << std::endl;

    test_b2a_bit<int8_t>(test_size);
    test_b2a_bit<int32_t>(test_size);
    test_b2a_bit<int64_t>(test_size);
    test_b2a_bit<__int128_t>(test_size);
    single_cout("B2A Bit Conversion...OK");

    test_b2a<int8_t>(100);
    test_b2a<int32_t>(100);
    test_b2a<int64_t>(100);
    test_b2a<__int128_t>(100);
    single_cout("B2A Conversion...OK");

    runTime->malicious_check();

    runTime->print_statistics();

// Tear down communication
#if defined(MPC_USE_MPI_COMMUNICATOR)
    MPI_Finalize();
#endif
    return 0;
}
